---
layout: post
title: "배열로 구현한 큐(Queue)"
tags: ["Java", "Data Structure"]
comments: true
---

큐(`Queue`)는 가장 먼저 입력된 데이터가 가장 먼저 출력되는 선입선출(`First In First Out`)의 대표적인 자료구조입니다. 오늘은 배열을 사용하여 큐를 구현해보도록 하겠습니다.

## 환형 배열(Circular Array)

큐를 구현할 때 사용하는 배열은 일반 배열과는 달리 환형 배열의 구조를 가집니다. 환형 배열이라고 특별한 기능이 있는 건 아니고, 배열의 마지막 인덱스와 첫 번째 인덱스가 이어진 배열이라고 생각하면 됩니다.

환형 배열에서는 모든 인덱스가 `0`번 인덱스가 될 수 있습니다. 그렇기 때문에 항상 첫 번째 인덱스를 알고 있어야 환형 배열을 올바르게 사용할 수 있습니다.

### Next Index

일반적으로 배열의 임의의 인덱스에 대해 다음 인덱스는 `(index  + 1)`로 표현할 수 있지만 환형 배열에서는 `(index + 1) % arrSize`로 표현해야 합니다. 왜냐하면 마지막 인덱스에서 단순히 `+1`을 하면 `Overflow`가 날 수 있기 때문입니다.

### Prev Index

임의의 인덱스에 대해 이전 인덱스는 조금 더 복잡합니다. `(index - 1) % arrSize`를 하면 음수가 나올 수 있기 때문에 항상 양수가 나올 수 있도록 `(index  - 1 + arrSize) % arrSize`를 해줘야 합니다.

## Implementation

아래와 같이 `Queue` 클래스의 필드와 메소드를 정의합니다.

```java
public class Queue {
    private final int[] arr;
    private final int maxSize;
    private int size;
    private int frontIndex;
    private int backIndex;

    Queue(int maxSize);
    public boolean empty();
    public boolean full();
    public int size();
    public int front();
    public int back();
    public void pushBack(int e);
    public int popFront();
}
```

### Fields

| Name | Description |
|:-:|-|
| arr | 데이터를 저장할 배열 |
| maxSize | 큐 최대 사이즈 |
| size | 큐의 사이즈 |
| frontIndex | 가장 먼저 입력된 데이터의 인덱스 |
| backIndex | 가장 최근에 입력된 데이터의 인덱스 |

### Constructor

배열의 크기는 정해져있기 때문에 큐를 생성할 때 생성자에서 `maxSize`를 인자로 받아 배열을 동적으로 할당해줍니다. `maxSize`는 큐가 가득차있는지 확인하는 척도가 됩니다.

`frontIndex`와 `backIndex`는 어떤 값으로 초기화되어도 상관없지만, 큐가 비어있는 경우 반드시 두 필드의 값이 같아야 합니다.

```java
Queue(int maxSize) {
    this.arr = new int[maxSize];
    this.maxSize = maxSize;
    this.size = 0;
    this.frontIndex = 0;
    this.backIndex = 0;
}
```

### empty()

큐에서는 `size` 필드를 사용하여 큐가 비어있는지 알 수 있습니다.

```java
public boolean empty() {
    return size == 0;
}
```

### full()

큐에서는 `size` 필드를 사용하여 큐가 가득차있는지 알 수 있습니다.

```java
public boolean full() {
    return size == maxSize;
}
```

### size()

큐에서는 `size` 필드를 사용하여 큐의 사이즈를 알 수 있습니다.

```java
public int size() {
    return size;
}
```

### front()

`frontIndex`를 사용하여 가장 먼저 입력된 데이터를 반환할 수 있습니다. 만약 큐가 비어있다면 예외 처리를 해줘야 합니다.

```java
public int front() {
    if (empty()) {
        throw new NoSuchElementException();
    }
    return arr[frontIndex];
}
```

### back()

`backIndex`를 사용하여 가장 최근에 입력된 데이터를 반환할 수 있습니다. 만약 큐가 비어있다면 예외 처리를 해줘야 합니다.

```java
public int back() {
    if (empty()) {
        throw new NoSuchElementException();
    }
    return arr[backIndex];
}
```

### pushBack()

`backIndex`의 다음 인덱스에 데이터를 삽입 후 `backIndex`와 `size`의 값을 `1` 증가시켜 줍니다. 만약 큐가 가득차있다면 예외 처리를 해줍니다.

```java
public void pushBack(int e) {
    if (full()) {
        throw new ArrayIndexOutOfBoundsException();
    }
    backIndex = empty() ? backIndex : (backIndex + 1) % maxSize;
    arr[backIndex] = e;
    size++;
}
```

### popFront()

`front()` 메서드를 통해 가장 먼저 입력된 데이터를 반환하고 `frontIndex`의 값을 `1` 증가시켜 줍니다. 만약 큐가 비어있다면 `front()` 메서드에서 예외 처리가 됩니다.

```java
public int popFront() {
    int ret = front();// if empty, throw exception
    size--;
    frontIndex = empty() ? frontIndex : (frontIndex + 1) % maxSize;
    return ret;
}
```

## Time Complexity

`Queue` 클래스의 각 메서드의 시간 복잡도는 다음과 같습니다.

| Method | Time Complexity |
|:-:|:-:|
| empty() | O(1) |
| full() | O(1) |
| size() | O(1) |
| front() | O(1) |
| back() | O(1) |
| pushBack() | O(1) |
| popFront() | O(1) |

## Full Source Code

```java
public class Queue {
    private final int[] arr;
    private final int maxSize;
    private int size;
    private int frontIndex;
    private int backIndex;

    public Queue(int maxSize) {
        this.arr = new int[maxSize];
        this.maxSize = maxSize;
        this.size = 0;
        this.frontIndex = 0;
        this.backIndex = 0;
    }

    public boolean empty() {
        return size == 0;
    }

    public boolean full() {
        return size == maxSize;
    }

    public int size() {
        return size;
    }

    public int front() {
        if (empty()) {
            throw new NoSuchElementException();
        }
        return arr[frontIndex];
    }

    public int back() {
        if (empty()) {
            throw new NoSuchElementException();
        }
        return arr[backIndex];
    }

    public void pushBack(int e) {
        if (full()) {
            throw new ArrayIndexOutOfBoundsException();
        }
        backIndex = empty() ? backIndex : (backIndex + 1) % maxSize;
        arr[backIndex] = e;
        size++;
    }

    public int popFront() {
        int ret = front();// if empty, throw exception
        size--;
        frontIndex = empty() ? frontIndex : (frontIndex + 1) % maxSize;
        return ret;
    }
}
```
